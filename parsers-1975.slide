Writing parsers like it is 1975
A practical introduction to Lex and Yacc
14 Jun 2019

Jiayu Yi

* Contents

- Why write a parser?
- What are Lex and Yacc?
- Building a simple calculator
- Final notes

* Why write a parser?

* There comes a point in the life of every programmer when they find themselves in need of a parser.

The novice programmer will ask, "what is a parser?"

The intermediate programmer will say, "that's easy, I'll write a regular expression."

The master programmer will say, "stand back, I know lex and yacc."

- From [[https://bodil.lol/parser-combinators/][https://bodil.lol/parser-combinators/]]

* You never know when it will come in useful

.image regular_expressions_smaller.png
.caption [[https://xkcd.com/208/][https://xkcd.com/208/]]

* What are Lex and Yacc?

* Lex

- Performs lexical analysis
- Splits input into tokens based on rules
- Performs actions when matching tokens

* Lex example

Input:

	logging {
		category lame-servers { null; };
		category cname { null; };
	};
	
	zone "." {
		type hint;
		file "/etc/bind/db.root";
	};

Output:

	WORD OBRACE 
	WORD FILENAME OBRACE WORD SEMICOLON EBRACE SEMICOLON 
	WORD WORD OBRACE WORD SEMICOLON EBRACE SEMICOLON 
	EBRACE SEMICOLON 

	WORD QUOTE FILENAME QUOTE OBRACE 
	WORD WORD SEMICOLON 
	WORD QUOTE FILENAME QUOTE SEMICOLON 
	EBRACE SEMICOLON 

* Yacc

- Consumes sequences of tokens
- Performs actions based on grammar rules

* Grammar example

Rules:

	exprs: exprs expr
	expr: literal | addition
	literal: NUMBER
	addition: NUMBER PLUS NUMBER

Input:

	123
	2 + 2
	-10

Tokens:

	NUMBER             # matches literal
	NUMBER PLUS NUMBER # matches addition
	MINUS NUMBER       # invalid

* Getting started

* Code samples

.link https://github.com/yi-jiayu/parsers-1975

* Lex file structure

	%{
	C declarations
	%}

	%%
	Rules
	%%

	Additional C code

- The second %% is optional

* Example 1

- `example1.l`:

	%{
	#include <stdio.h>
	%}

	%%
	stop    printf("Stop command received\n");
	start   printf("Start command received\n");
	%%

- To compile:

	lex example1.l
	cc lex.yy.c -o example1 -ll

* Example 1

- Output:

	$ ./example1
	start
	Start command received

	stop
	Stop command received

	pause
	pause

- Matching "start" or "stop" triggers the corresponding action
- Unmatched input is passed through

* Example 2

- `example2.l`:

	%{
	#include <stdio.h>
	%}

	%%
	[0-9]+  printf("NUMBER ");
	\+      printf("PLUS ");
	-       printf("MINUS ");
	\*      printf("TIMES ");
	\/      printf("DIVIDE ");
	[ \t]   ; // match and ignore whitespace
	%%

- Regular expressions can be used to match tokens

* Example 2

- Output:

	$ ./example2
	123
	NUMBER 
	11 + 23 - 5 / 10 * 5
	NUMBER PLUS NUMBER MINUS NUMBER DIVIDE NUMBER TIMES NUMBER 
	C++ **5** /100/
	CPLUS PLUS TIMES TIMES NUMBER TIMES TIMES DIVIDE NUMBER DIVIDE

- Lex doesn't care about invalid input

* Example 3

- Let's do some parsing!
- `example3.l`:

	%{
	#include <stdio.h>
	#include "y.tab.h"
	%}

	%%
	[0-9]+  return NUMBER;
	\+      return PLUS;
	-       return MINUS;
	\*      return TIMES;
	\/      return DIVIDE;
	\n      return EOL;
	[ \t]+  ; // match and ignore whitespace
	%%

- Return tokens instead of printing
- Tokens are defined in `y.tab.h`, which will be generated by Yacc

* Yacc file structure

	%{
	C declarations
	%}

	Yacc declarations

	%%
	Grammar rules
	%%

	Additional C code

- The next few slides will be referring to `example3.y`

* C declarations

.code -numbers example3.y 1,16

- `yyerror` is called by Yacc on errors
- `yywrap` is used to read from multiple files. Returning 1 indicates the end of input
- `yyparse` is the entry point for the generated parser

* Yacc declarations:

.code -numbers example3.y 18

- This is where we define the tokens that Lex will return

* Grammar rules

.code -numbers example3.y 20,28

- The first nonterminal symbol is where parsing will start

* Grammar rules continued

.code -numbers example3.y 30,35

* Grammar rules continued

.code -numbers example3.y 37,49

* Grammar rules continued

.code -numbers example3.y 51,63

* Example 3

- Compilation:

.code Makefile 10,12

- Output:

	$ ./example3
	123
	Got a number!
	2 + 2
	Adding two numbers!
	10*4
	Multiplying two numbers!
	1/0
	Dividing a number by another!
	-1
	error: syntax error

- Does not actually recognise the value of the tokens yet
- Syntax error when rules are not matched

* Example 4

- Lex can associate a number token with its numeric value
- `example4.l`:

.code example4.l

- `yyval` is a variable that will be accessible to the parser

* Example 4

- Now we can print the actual value of the calculation instead of a generic message:

.code -numbers example4.y 30,42

- The value of `yyval` can be accessed using `$` syntax with the correspoding index

* Example 4

.code -numbers example4.y 44,63

* Example 4

- Output:

	$ ./example4
	123
	= 123
	2 + 2
	= 4
	1*4
	= 4
	1/0
	Floating point exception: 8

- Finally, a working calculator!
- Handling floating point exceptions in C is a whole other story

* Example 5

- Time for some refactoring!
- We had a lot of repetition in our rules, let's try to reduce that
- It would be nice to handle negative numbers as well

* Semantic values

- Instead of having separate actions for each type of expression, we can use the `$$` variable which represents the value of a rule:

	expr:
	    NUMBER { $$ = $1; }
	    |
	    MINUS NUMBER { $$ = -$2; }
	    |
	    NUMBER PLUS NUMBER { $$ = $1 + $3; }
	    |
	    NUMBER MINUS NUMBER { $$ = $1 - $3; }
	    |
	    NUMBER TIMES NUMBER { $$ = $1 * $3; }
	    |
	    NUMBER DIVIDE NUMBER { $$ = $1 / $3; }
	    ;

- This sets the value of an `expr` based on the matching rule
- We can add a rule for negative numbers too

* Semantic values

- Then we can modify our grammar to immediately print the value of an `expr`:

.code example5.y 22,33

* One step further

- We also didn't need to define individual tokens for each operation like we did previously:

.code example4.l 7,13 HLxxx

- Let's just match all single characters, returning their `char` value in `example5.l`:

.code example5.l 7,10

* Example 5

- Then we can directly use character literals in our Yacc file:

.code -numbers example5.y 35,46

- We don't have to declare the other tokens anymore:

.code -numbers example5.y 18

* Example 5

- Output:

	$ ./example5
	-1
	= -1
	1000+333
	= 1333

- Still working!

* Example 6

- A good calculator should accept more than two operands at a time, for example `1+2+3`
- It should also respect the order of operations
- Yacc allows us to define associativity and precedence

* Example 6

- We can include precedence and associativity declarations, which are listed increasing order of precedence:

.code -numbers example6.y 20,22

- The pseudo-symbol `NEG` will be used to ensure negative numbers are handled correctly

* Example 6

- Next we can define `expr` recursively to handle any number of operands:

.code -numbers example6.y 39,51

- We specify that the rule for negative numbers follows the precedence of our `NEG` symbol, which was declared last and hence has the highest precedence.

* Example 6

- Output:

	$ ./example6
	-1 + 1
	= 0
	1 + -1
	= 0
	2 + 4 * 4
	= 18
	3 * 3 * 3 * 3
	= 81
	3 * 3 * 3 * 3 * -1
	= -81

- Great!

* Example 7

- Finally, let's add some error handling, so our calculator doesn't crash after a single bad input
- Yacc supports the special `error` rule, which can be used to catch syntax errors

* Example 7

- A line can either be empty, contain an expression or contain an error:

.code -numbers example7.y 30,42

- `yyerrok` is a special macro which resets the parser state after an error

* Example 7

- Output:

	$ ./example7
	hello
	error: syntax error
	i'm late
	error: syntax error
	1 * 2 * 3 * 4
	= 24

- All ok!


* References

[[https://en.wikipedia.org/wiki/Lex_(software)][https://en.wikipedia.org/wiki/Lex_(software)]]
[[https://en.wikipedia.org/wiki/Yacc][https://en.wikipedia.org/wiki/Yacc]]
[[https://ieeexplore.ieee.org/document/8227293][https://ieeexplore.ieee.org/document/8227293]]
[[https://bodil.lol/parser-combinators/][https://bodil.lol/parser-combinators/]]
[[https://ds9a.nl/lex-yacc/cvs/output/lexyacc.html][https://ds9a.nl/lex-yacc/cvs/output/lexyacc.html]]
[[https://www2.cs.arizona.edu/classes/cs453/fall14/DOCS/tutorial-large.pdf][https://www2.cs.arizona.edu/classes/cs453/fall14/DOCS/tutorial-large.pdf]]
[[http://cse.iitkgp.ac.in/~bivasm/notes/LexAndYaccTutorial.pdf][http://cse.iitkgp.ac.in/~bivasm/notes/LexAndYaccTutorial.pdf]]
[[http://www.cse.scu.edu/~mwang2/compiler/TutorialLexYacc.pdf][http://www.cse.scu.edu/~mwang2/compiler/TutorialLexYacc.pdf]]
[[https://cs.wmich.edu/~yang/teach/cs485/yacc.pdf][https://cs.wmich.edu/~yang/teach/cs485/yacc.pdf]]
[[http://www-h.eng.cam.ac.uk/help/tpl/languages/flexbison/][http://www-h.eng.cam.ac.uk/help/tpl/languages/flexbison/]]
[[https://www.gnu.org/software/bison/manual/html_node/index.html#SEC_Contents][https://www.gnu.org/software/bison/manual/html_node/index.html#SEC_Contents]]
[[http://dinosaur.compilertools.net/lex/index.html][http://dinosaur.compilertools.net/lex/index.html]]
